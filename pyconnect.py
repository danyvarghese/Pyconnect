import reclass Clause(object):    def __init__(self,mode):        mode = mode.replace("[[", "$[", 100)        mode = mode.replace("]]", "], *", 100)        self.predicate,_,body=mode.replace(" ", "").partition('(')        self.body=body.strip().split(')')    def args(name):        args=[]        if "[" in name.body[0]:            for i in name.body[0].split("["):                if "]" in i:                    ans=split_into_args(i)                    for j in ans:                        if j:                            args.append(j)                else:                    for j in  i.split(","):                        if j:                            args.append(j)        else:            for arg_str in name.body[0].split(','):                if arg_str:                    if arg_str:                        args.append(arg_str)        if "$" in name.body[0]:            return(convert_set_list(args))        else:            return args        def generate_literal(predicate,args):    head=predicate    start="("    for i in args:        start=start+str(i)+","    body=start[0:-1]+")"    clause=head+body    return clausedef extract_actions(plan_1):        # Extract actionType and the raw actionParams    actions = re.findall(r'actionType\(([^)]+)\).*?actionParams\((\[.*?\])\)', plan_1)        # Process the extracted actionParams to remove x and y    cleaned_actions = [(atype, re.findall(r'(\d+\.\d+)', params)) for atype, params in actions]    cleaned_actions.reverse()        # List to save rules extracted    rule_list = []        # Generating first clause and saves it a list    for eachactionset in cleaned_actions:        rule = generate_literal(eachactionset[0],eachactionset[1])        rule_list.append(rule)    return rule_list